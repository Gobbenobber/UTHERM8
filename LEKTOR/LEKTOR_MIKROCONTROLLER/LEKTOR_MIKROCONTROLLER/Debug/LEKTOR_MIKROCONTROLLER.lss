
LEKTOR_MIKROCONTROLLER.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         0000000c  00800200  00000ba0  00000c34  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         00000ba0  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          0000001b  0080020c  0080020c  00000c40  2**0
                  ALLOC
  3 .comment      00000030  00000000  00000000  00000c40  2**0
                  CONTENTS, READONLY
  4 .note.gnu.avr.deviceinfo 00000040  00000000  00000000  00000c70  2**2
                  CONTENTS, READONLY
  5 .debug_aranges 00000178  00000000  00000000  00000cb0  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   0000177b  00000000  00000000  00000e28  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 000010ea  00000000  00000000  000025a3  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   000011e7  00000000  00000000  0000368d  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  0000030c  00000000  00000000  00004874  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    00000837  00000000  00000000  00004b80  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    000009f8  00000000  00000000  000053b7  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 00000168  00000000  00000000  00005daf  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
   0:	95 c0       	rjmp	.+298    	; 0x12c <__ctors_end>
   2:	00 00       	nop
   4:	6d c4       	rjmp	.+2266   	; 0x8e0 <__vector_1>
   6:	00 00       	nop
   8:	b0 c0       	rjmp	.+352    	; 0x16a <__bad_interrupt>
   a:	00 00       	nop
   c:	ae c0       	rjmp	.+348    	; 0x16a <__bad_interrupt>
   e:	00 00       	nop
  10:	ac c0       	rjmp	.+344    	; 0x16a <__bad_interrupt>
  12:	00 00       	nop
  14:	aa c0       	rjmp	.+340    	; 0x16a <__bad_interrupt>
  16:	00 00       	nop
  18:	a8 c0       	rjmp	.+336    	; 0x16a <__bad_interrupt>
  1a:	00 00       	nop
  1c:	a6 c0       	rjmp	.+332    	; 0x16a <__bad_interrupt>
  1e:	00 00       	nop
  20:	a4 c0       	rjmp	.+328    	; 0x16a <__bad_interrupt>
  22:	00 00       	nop
  24:	a2 c0       	rjmp	.+324    	; 0x16a <__bad_interrupt>
  26:	00 00       	nop
  28:	a0 c0       	rjmp	.+320    	; 0x16a <__bad_interrupt>
  2a:	00 00       	nop
  2c:	9e c0       	rjmp	.+316    	; 0x16a <__bad_interrupt>
  2e:	00 00       	nop
  30:	9c c0       	rjmp	.+312    	; 0x16a <__bad_interrupt>
  32:	00 00       	nop
  34:	9a c0       	rjmp	.+308    	; 0x16a <__bad_interrupt>
  36:	00 00       	nop
  38:	98 c0       	rjmp	.+304    	; 0x16a <__bad_interrupt>
  3a:	00 00       	nop
  3c:	96 c0       	rjmp	.+300    	; 0x16a <__bad_interrupt>
  3e:	00 00       	nop
  40:	94 c0       	rjmp	.+296    	; 0x16a <__bad_interrupt>
  42:	00 00       	nop
  44:	92 c0       	rjmp	.+292    	; 0x16a <__bad_interrupt>
  46:	00 00       	nop
  48:	90 c0       	rjmp	.+288    	; 0x16a <__bad_interrupt>
  4a:	00 00       	nop
  4c:	8e c0       	rjmp	.+284    	; 0x16a <__bad_interrupt>
  4e:	00 00       	nop
  50:	72 c2       	rjmp	.+1252   	; 0x536 <__vector_20>
  52:	00 00       	nop
  54:	8a c0       	rjmp	.+276    	; 0x16a <__bad_interrupt>
  56:	00 00       	nop
  58:	88 c0       	rjmp	.+272    	; 0x16a <__bad_interrupt>
  5a:	00 00       	nop
  5c:	86 c0       	rjmp	.+268    	; 0x16a <__bad_interrupt>
  5e:	00 00       	nop
  60:	84 c0       	rjmp	.+264    	; 0x16a <__bad_interrupt>
  62:	00 00       	nop
  64:	82 c0       	rjmp	.+260    	; 0x16a <__bad_interrupt>
  66:	00 00       	nop
  68:	80 c0       	rjmp	.+256    	; 0x16a <__bad_interrupt>
  6a:	00 00       	nop
  6c:	7e c0       	rjmp	.+252    	; 0x16a <__bad_interrupt>
  6e:	00 00       	nop
  70:	7c c0       	rjmp	.+248    	; 0x16a <__bad_interrupt>
  72:	00 00       	nop
  74:	7a c0       	rjmp	.+244    	; 0x16a <__bad_interrupt>
  76:	00 00       	nop
  78:	78 c0       	rjmp	.+240    	; 0x16a <__bad_interrupt>
  7a:	00 00       	nop
  7c:	76 c0       	rjmp	.+236    	; 0x16a <__bad_interrupt>
  7e:	00 00       	nop
  80:	74 c0       	rjmp	.+232    	; 0x16a <__bad_interrupt>
  82:	00 00       	nop
  84:	72 c0       	rjmp	.+228    	; 0x16a <__bad_interrupt>
  86:	00 00       	nop
  88:	70 c0       	rjmp	.+224    	; 0x16a <__bad_interrupt>
  8a:	00 00       	nop
  8c:	6e c0       	rjmp	.+220    	; 0x16a <__bad_interrupt>
  8e:	00 00       	nop
  90:	6c c0       	rjmp	.+216    	; 0x16a <__bad_interrupt>
  92:	00 00       	nop
  94:	6a c0       	rjmp	.+212    	; 0x16a <__bad_interrupt>
  96:	00 00       	nop
  98:	68 c0       	rjmp	.+208    	; 0x16a <__bad_interrupt>
  9a:	00 00       	nop
  9c:	66 c0       	rjmp	.+204    	; 0x16a <__bad_interrupt>
  9e:	00 00       	nop
  a0:	64 c0       	rjmp	.+200    	; 0x16a <__bad_interrupt>
  a2:	00 00       	nop
  a4:	62 c0       	rjmp	.+196    	; 0x16a <__bad_interrupt>
  a6:	00 00       	nop
  a8:	60 c0       	rjmp	.+192    	; 0x16a <__bad_interrupt>
  aa:	00 00       	nop
  ac:	5e c0       	rjmp	.+188    	; 0x16a <__bad_interrupt>
  ae:	00 00       	nop
  b0:	5c c0       	rjmp	.+184    	; 0x16a <__bad_interrupt>
  b2:	00 00       	nop
  b4:	5a c0       	rjmp	.+180    	; 0x16a <__bad_interrupt>
  b6:	00 00       	nop
  b8:	58 c0       	rjmp	.+176    	; 0x16a <__bad_interrupt>
  ba:	00 00       	nop
  bc:	56 c0       	rjmp	.+172    	; 0x16a <__bad_interrupt>
  be:	00 00       	nop
  c0:	54 c0       	rjmp	.+168    	; 0x16a <__bad_interrupt>
  c2:	00 00       	nop
  c4:	52 c0       	rjmp	.+164    	; 0x16a <__bad_interrupt>
  c6:	00 00       	nop
  c8:	50 c0       	rjmp	.+160    	; 0x16a <__bad_interrupt>
  ca:	00 00       	nop
  cc:	4e c0       	rjmp	.+156    	; 0x16a <__bad_interrupt>
  ce:	00 00       	nop
  d0:	4c c0       	rjmp	.+152    	; 0x16a <__bad_interrupt>
  d2:	00 00       	nop
  d4:	4a c0       	rjmp	.+148    	; 0x16a <__bad_interrupt>
  d6:	00 00       	nop
  d8:	48 c0       	rjmp	.+144    	; 0x16a <__bad_interrupt>
  da:	00 00       	nop
  dc:	46 c0       	rjmp	.+140    	; 0x16a <__bad_interrupt>
  de:	00 00       	nop
  e0:	44 c0       	rjmp	.+136    	; 0x16a <__bad_interrupt>
  e2:	00 00       	nop
  e4:	ee 01       	movw	r28, r28
  e6:	fc 01       	movw	r30, r24
  e8:	0a 02       	muls	r16, r26
  ea:	18 02       	muls	r17, r24
  ec:	26 02       	muls	r18, r22
  ee:	34 02       	muls	r19, r20
  f0:	42 02       	muls	r20, r18
  f2:	50 02       	muls	r21, r16
  f4:	8f 02       	muls	r24, r31
  f6:	60 02       	muls	r22, r16
  f8:	70 02       	muls	r23, r16
  fa:	80 02       	muls	r24, r16
  fc:	06 03       	mulsu	r16, r22
  fe:	14 03       	mulsu	r17, r20
 100:	22 03       	mulsu	r18, r18
 102:	30 03       	mulsu	r19, r16
 104:	3e 03       	fmul	r19, r22
 106:	4c 03       	fmul	r20, r20
 108:	5a 03       	fmul	r21, r18
 10a:	68 03       	fmul	r22, r16
 10c:	a7 03       	fmuls	r18, r23
 10e:	78 03       	fmul	r23, r16
 110:	88 03       	fmulsu	r16, r16
 112:	98 03       	fmulsu	r17, r16
 114:	d2 03       	fmuls	r21, r18
 116:	df 03       	fmulsu	r21, r23
 118:	ec 03       	fmulsu	r22, r20
 11a:	f9 03       	fmulsu	r23, r17
 11c:	06 04       	cpc	r0, r6
 11e:	13 04       	cpc	r1, r3
 120:	20 04       	cpc	r2, r0
 122:	2d 04       	cpc	r2, r13
 124:	68 04       	cpc	r6, r8
 126:	3c 04       	cpc	r3, r12
 128:	4b 04       	cpc	r4, r11
 12a:	5a 04       	cpc	r5, r10

0000012c <__ctors_end>:
 12c:	11 24       	eor	r1, r1
 12e:	1f be       	out	0x3f, r1	; 63
 130:	cf ef       	ldi	r28, 0xFF	; 255
 132:	d1 e2       	ldi	r29, 0x21	; 33
 134:	de bf       	out	0x3e, r29	; 62
 136:	cd bf       	out	0x3d, r28	; 61
 138:	00 e0       	ldi	r16, 0x00	; 0
 13a:	0c bf       	out	0x3c, r16	; 60

0000013c <__do_copy_data>:
 13c:	12 e0       	ldi	r17, 0x02	; 2
 13e:	a0 e0       	ldi	r26, 0x00	; 0
 140:	b2 e0       	ldi	r27, 0x02	; 2
 142:	e0 ea       	ldi	r30, 0xA0	; 160
 144:	fb e0       	ldi	r31, 0x0B	; 11
 146:	00 e0       	ldi	r16, 0x00	; 0
 148:	0b bf       	out	0x3b, r16	; 59
 14a:	02 c0       	rjmp	.+4      	; 0x150 <__do_copy_data+0x14>
 14c:	07 90       	elpm	r0, Z+
 14e:	0d 92       	st	X+, r0
 150:	ac 30       	cpi	r26, 0x0C	; 12
 152:	b1 07       	cpc	r27, r17
 154:	d9 f7       	brne	.-10     	; 0x14c <__do_copy_data+0x10>

00000156 <__do_clear_bss>:
 156:	22 e0       	ldi	r18, 0x02	; 2
 158:	ac e0       	ldi	r26, 0x0C	; 12
 15a:	b2 e0       	ldi	r27, 0x02	; 2
 15c:	01 c0       	rjmp	.+2      	; 0x160 <.do_clear_bss_start>

0000015e <.do_clear_bss_loop>:
 15e:	1d 92       	st	X+, r1

00000160 <.do_clear_bss_start>:
 160:	a7 32       	cpi	r26, 0x27	; 39
 162:	b2 07       	cpc	r27, r18
 164:	e1 f7       	brne	.-8      	; 0x15e <.do_clear_bss_loop>
 166:	51 d0       	rcall	.+162    	; 0x20a <main>
 168:	19 c5       	rjmp	.+2610   	; 0xb9c <_exit>

0000016a <__bad_interrupt>:
 16a:	4a cf       	rjmp	.-364    	; 0x0 <__vectors>

0000016c <start1msDelay>:
 }

  void start1msDelay()
  {
	  // Timer3: Normal mode, PS = 0
	  TCCR3A = 0b00000000;
 16c:	10 92 90 00 	sts	0x0090, r1	; 0x800090 <__TEXT_REGION_LENGTH__+0x700090>
	  TCCR3B = 0b00000001;
 170:	81 e0       	ldi	r24, 0x01	; 1
 172:	80 93 91 00 	sts	0x0091, r24	; 0x800091 <__TEXT_REGION_LENGTH__+0x700091>
	  // Overflow hvert MS.
	  //Sæt timerStatus til '1' (=going)
	  //timerStatus_3 = '1';
	  TCNT3 = (0xFFFF-16000);
 176:	8f e7       	ldi	r24, 0x7F	; 127
 178:	91 ec       	ldi	r25, 0xC1	; 193
 17a:	90 93 95 00 	sts	0x0095, r25	; 0x800095 <__TEXT_REGION_LENGTH__+0x700095>
 17e:	80 93 94 00 	sts	0x0094, r24	; 0x800094 <__TEXT_REGION_LENGTH__+0x700094>
	  while ((TIFR3 & (1<<0)) == 0)
 182:	c0 9b       	sbis	0x18, 0	; 24
 184:	fe cf       	rjmp	.-4      	; 0x182 <start1msDelay+0x16>
	  {}
	  TCCR3B = 0;
 186:	10 92 91 00 	sts	0x0091, r1	; 0x800091 <__TEXT_REGION_LENGTH__+0x700091>
	  TIFR3 = 1<<0;
 18a:	81 e0       	ldi	r24, 0x01	; 1
 18c:	88 bb       	out	0x18, r24	; 24
 18e:	08 95       	ret

00000190 <sendBurst>:
	  //timerStatus_3 = '0';
  }

  void sendBurst()
  {
	  ZCDetected_ = 0;
 190:	10 92 20 02 	sts	0x0220, r1	; 0x800220 <ZCDetected_+0x1>
 194:	10 92 1f 02 	sts	0x021F, r1	; 0x80021f <ZCDetected_>
	  //PORTB = OUTPUT -- lad 120kHz signal fra OCRB komme ud.
	  DDRB |= 1 << 7;
	  start1msDelay();
 198:	27 9a       	sbi	0x04, 7	; 4
	  //Sæt PORTH til input igen.
	  DDRB &= ~(1 << 7);
 19a:	e8 df       	rcall	.-48     	; 0x16c <start1msDelay>
 19c:	27 98       	cbi	0x04, 7	; 4
 19e:	08 95       	ret

000001a0 <ventPaaZC>:
  }

  void ventPaaZC()
  {
	  ZCDetected_ = 0;
 1a0:	10 92 20 02 	sts	0x0220, r1	; 0x800220 <ZCDetected_+0x1>
 1a4:	10 92 1f 02 	sts	0x021F, r1	; 0x80021f <ZCDetected_>
	  while(ZCDetected_ == 0)	{}
 1a8:	80 91 1f 02 	lds	r24, 0x021F	; 0x80021f <ZCDetected_>
 1ac:	90 91 20 02 	lds	r25, 0x0220	; 0x800220 <ZCDetected_+0x1>
 1b0:	89 2b       	or	r24, r25
 1b2:	d1 f3       	breq	.-12     	; 0x1a8 <ventPaaZC+0x8>
  }
 1b4:	08 95       	ret

000001b6 <initBurst>:

  void initBurst()
  {
	  // PH = input (burst not outgoing)
	  DDRH = 0;
 1b6:	10 92 01 01 	sts	0x0101, r1	; 0x800101 <__TEXT_REGION_LENGTH__+0x700101>
	  // Toggle OC2B on compare match
	  // Mode = 4 (CTC)
	  // Clock prescaler = 1
	  TCCR0A = 0b01000010;
 1ba:	82 e4       	ldi	r24, 0x42	; 66
 1bc:	84 bd       	out	0x24, r24	; 36
	  TCCR0B = 0b00000001;
 1be:	91 e0       	ldi	r25, 0x01	; 1
 1c0:	95 bd       	out	0x25, r25	; 37
	  // 120kHz = 16000000Hz/(2*1*(1+OCR1B))  --> OCR1B = 119kHz...
	  OCR0A = 66;
 1c2:	87 bd       	out	0x27, r24	; 39
 1c4:	08 95       	ret

000001c6 <start400usDelay>:
  }

   void start400usDelay()
   {
	   // Timer4: Normal mode, PS = 0
	   TCCR4A = 0b00000000;
 1c6:	10 92 a0 00 	sts	0x00A0, r1	; 0x8000a0 <__TEXT_REGION_LENGTH__+0x7000a0>
	   TCCR4B = 0b00000001;
 1ca:	81 e0       	ldi	r24, 0x01	; 1
 1cc:	80 93 a1 00 	sts	0x00A1, r24	; 0x8000a1 <__TEXT_REGION_LENGTH__+0x7000a1>
	   // Overflow hvert MS.
	   //Sæt timerStatus til '1' (=going)
	   //timerStatus_3 = '1';
	   TCNT4 = 63936;
 1d0:	80 ec       	ldi	r24, 0xC0	; 192
 1d2:	99 ef       	ldi	r25, 0xF9	; 249
 1d4:	90 93 a5 00 	sts	0x00A5, r25	; 0x8000a5 <__TEXT_REGION_LENGTH__+0x7000a5>
 1d8:	80 93 a4 00 	sts	0x00A4, r24	; 0x8000a4 <__TEXT_REGION_LENGTH__+0x7000a4>
	   while ((TIFR4 & (1<<0)) == 0)
 1dc:	c8 9b       	sbis	0x19, 0	; 25
 1de:	fe cf       	rjmp	.-4      	; 0x1dc <start400usDelay+0x16>
	   {}
	   TCCR4B = 0;
 1e0:	10 92 a1 00 	sts	0x00A1, r1	; 0x8000a1 <__TEXT_REGION_LENGTH__+0x7000a1>
	   TIFR4 = 1<<0;
 1e4:	81 e0       	ldi	r24, 0x01	; 1
 1e6:	89 bb       	out	0x19, r24	; 25
 1e8:	08 95       	ret

000001ea <sendCharX10>:
	  // 120kHz = 16000000Hz/(2*1*(1+OCR1B))  --> OCR1B = 119kHz...
	  OCR0A = 66;
  }

  void sendCharX10(char Tegn)
  {
 1ea:	cf 93       	push	r28
 1ec:	df 93       	push	r29
 1ee:	d8 2f       	mov	r29, r24
	  // 8 data bits (LSB first)
	  for (i = 0; i<8; i++)
	  {
	  ventPaaZC();
	  start1msDelay();
	  start1msDelay();
 1f0:	c8 e0       	ldi	r28, 0x08	; 8
	  start400usDelay();
 1f2:	d6 df       	rcall	.-84     	; 0x1a0 <ventPaaZC>
 1f4:	bb df       	rcall	.-138    	; 0x16c <start1msDelay>
		  if(x & 0b00000001)
 1f6:	ba df       	rcall	.-140    	; 0x16c <start1msDelay>
		  {
			  sendBurst();
 1f8:	e6 df       	rcall	.-52     	; 0x1c6 <start400usDelay>
 1fa:	d0 fd       	sbrc	r29, 0
		  }
		  x = x>>1;
 1fc:	c9 df       	rcall	.-110    	; 0x190 <sendBurst>
 1fe:	d6 95       	lsr	r29
	  unsigned char x = Tegn;
	  // Start bit
	  //ventPaaZC();
	  //sendBurst();
	  // 8 data bits (LSB first)
	  for (i = 0; i<8; i++)
 200:	c1 50       	subi	r28, 0x01	; 1
		  x = x>>1;
	  }
	  //ventPaaZC();
	  //sendBurst(); //stopbit
	  //Test ###DUNNO what the stopbit is###
  }
 202:	b9 f7       	brne	.-18     	; 0x1f2 <sendCharX10+0x8>
 204:	df 91       	pop	r29
 206:	cf 91       	pop	r28
 208:	08 95       	ret

0000020a <main>:
#include "ToggleSwitchLED.h"
#include "zeroCrossDetector.h"
#include "X10_Master.h"

int main(void)
{
 20a:	cf 93       	push	r28
 20c:	df 93       	push	r29
 20e:	1f 92       	push	r1
 210:	cd b7       	in	r28, 0x3d	; 61
 212:	de b7       	in	r29, 0x3e	; 62
	//Initializing
	initSensor('B', 2);
 214:	62 e0       	ldi	r22, 0x02	; 2
 216:	70 e0       	ldi	r23, 0x00	; 0
 218:	82 e4       	ldi	r24, 0x42	; 66
 21a:	ba d0       	rcall	.+372    	; 0x390 <initSensor>
	initToggleSwitch('B', 3);
 21c:	63 e0       	ldi	r22, 0x03	; 3
 21e:	70 e0       	ldi	r23, 0x00	; 0
 220:	82 e4       	ldi	r24, 0x42	; 66
 222:	ca d1       	rcall	.+916    	; 0x5b8 <initToggleSwitch>
	initToggleSwitchLED('B', 4);
 224:	64 e0       	ldi	r22, 0x04	; 4
 226:	70 e0       	ldi	r23, 0x00	; 0
	initZCDetector();
 228:	82 e4       	ldi	r24, 0x42	; 66
 22a:	92 d2       	rcall	.+1316   	; 0x750 <initToggleSwitchLED>
	initBurst();
 22c:	52 d3       	rcall	.+1700   	; 0x8d2 <initZCDetector>
 22e:	c3 df       	rcall	.-122    	; 0x1b6 <initBurst>
	
	// Global interrupt enable
	sei();

	//Streng med data som skal sendes.
	unsigned char streng[2] = {LEKTORID1, COMMAND};
 230:	78 94       	sei
	//Streng som er manchester-encoded (strengen som egentlig sendes).
	unsigned char* konverteretStreng;
	//Char (fra konverteretStreng) som aktuelt afsendes.
	volatile unsigned char karakter = '\0';
 232:	80 91 22 02 	lds	r24, 0x0222	; 0x800222 <COMMAND>
		//{
		//sendCharX10(konverteretStreng[i]);
		//}
		//freePtr();
		//sendCharX10(STARTCODE);
		const unsigned char* klunk = stringToManchester("ABCD");
 236:	19 82       	std	Y+1, r1	; 0x01
 238:	86 e0       	ldi	r24, 0x06	; 6
 23a:	92 e0       	ldi	r25, 0x02	; 2
 23c:	1d d0       	rcall	.+58     	; 0x278 <stringToManchester>
		for (i = 0; i < strlen(klunk); i++)
 23e:	7c 01       	movw	r14, r24
 240:	6c 01       	movw	r12, r24
		{
			sendCharX10(klunk[i]);
 242:	00 e0       	ldi	r16, 0x00	; 0
 244:	10 e0       	ldi	r17, 0x00	; 0
 246:	06 c0       	rjmp	.+12     	; 0x254 <main+0x4a>
 248:	f6 01       	movw	r30, r12
 24a:	81 91       	ld	r24, Z+
		//sendCharX10(konverteretStreng[i]);
		//}
		//freePtr();
		//sendCharX10(STARTCODE);
		const unsigned char* klunk = stringToManchester("ABCD");
		for (i = 0; i < strlen(klunk); i++)
 24c:	6f 01       	movw	r12, r30
 24e:	cd df       	rcall	.-102    	; 0x1ea <sendCharX10>
 250:	0f 5f       	subi	r16, 0xFF	; 255
 252:	1f 4f       	sbci	r17, 0xFF	; 255
 254:	f7 01       	movw	r30, r14
 256:	01 90       	ld	r0, Z+
 258:	00 20       	and	r0, r0
 25a:	e9 f7       	brne	.-6      	; 0x256 <main+0x4c>
 25c:	31 97       	sbiw	r30, 0x01	; 1
 25e:	ee 19       	sub	r30, r14
 260:	ff 09       	sbc	r31, r15
		{
			sendCharX10(klunk[i]);
		}
		freePtr();
 262:	0e 17       	cp	r16, r30
 264:	1f 07       	cpc	r17, r31
		//start1msDelay();
		//start400usDelay();
		//sendBurst();
		//freePtr();
		//}
	}
 266:	80 f3       	brcs	.-32     	; 0x248 <main+0x3e>
 268:	01 d0       	rcall	.+2      	; 0x26c <freePtr>
 26a:	e6 cf       	rjmp	.-52     	; 0x238 <main+0x2e>

0000026c <freePtr>:
#include "Manchester.h"

static unsigned char * manchesterPtr = 0;

void freePtr(){
	free(manchesterPtr);
 26c:	80 91 0c 02 	lds	r24, 0x020C	; 0x80020c <__data_end>
 270:	90 91 0d 02 	lds	r25, 0x020D	; 0x80020d <__data_end+0x1>
 274:	03 c4       	rjmp	.+2054   	; 0xa7c <free>
 276:	08 95       	ret

00000278 <stringToManchester>:
}

unsigned char* stringToManchester(unsigned char* toBeConverted)
{
 278:	8f 92       	push	r8
 27a:	9f 92       	push	r9
 27c:	af 92       	push	r10
 27e:	bf 92       	push	r11
 280:	cf 92       	push	r12
 282:	df 92       	push	r13
 284:	ef 92       	push	r14
 286:	ff 92       	push	r15
 288:	0f 93       	push	r16
 28a:	1f 93       	push	r17
 28c:	cf 93       	push	r28
 28e:	df 93       	push	r29
	if (toBeConverted == (unsigned char*)"") return 0;						// Hvis der ikke er input, return 0 
 290:	22 e0       	ldi	r18, 0x02	; 2
 292:	8a 30       	cpi	r24, 0x0A	; 10
 294:	92 07       	cpc	r25, r18
 296:	09 f4       	brne	.+2      	; 0x29a <stringToManchester+0x22>
 298:	6c c0       	rjmp	.+216    	; 0x372 <stringToManchester+0xfa>
 29a:	ec 01       	movw	r28, r24
	int len = strlen((char*)toBeConverted);											// Lav size_t som kan passes til calloc.
 29c:	fc 01       	movw	r30, r24
 29e:	01 90       	ld	r0, Z+
 2a0:	00 20       	and	r0, r0
 2a2:	e9 f7       	brne	.-6      	; 0x29e <stringToManchester+0x26>
 2a4:	31 97       	sbiw	r30, 0x01	; 1
 2a6:	e8 1b       	sub	r30, r24
 2a8:	f9 0b       	sbc	r31, r25
 2aa:	5f 01       	movw	r10, r30
	manchesterPtr = (unsigned char *)calloc((((len+1) * 2) + 1), 1);				// Alloker hukommelse
 2ac:	cf 01       	movw	r24, r30
 2ae:	88 0f       	add	r24, r24
 2b0:	99 1f       	adc	r25, r25
 2b2:	61 e0       	ldi	r22, 0x01	; 1
 2b4:	70 e0       	ldi	r23, 0x00	; 0
 2b6:	03 96       	adiw	r24, 0x03	; 3
 2b8:	2f d3       	rcall	.+1630   	; 0x918 <calloc>
 2ba:	90 93 0d 02 	sts	0x020D, r25	; 0x80020d <__data_end+0x1>
 2be:	80 93 0c 02 	sts	0x020C, r24	; 0x80020c <__data_end>
	int counter = 8;
	int t = 0;

	for (int i = 0; i < len; ++i)
 2c2:	1a 14       	cp	r1, r10
 2c4:	1b 04       	cpc	r1, r11
 2c6:	0c f0       	brlt	.+2      	; 0x2ca <stringToManchester+0x52>
 2c8:	56 c0       	rjmp	.+172    	; 0x376 <stringToManchester+0xfe>
 2ca:	7e 01       	movw	r14, r28
 2cc:	a0 e0       	ldi	r26, 0x00	; 0
 2ce:	b0 e0       	ldi	r27, 0x00	; 0
 2d0:	60 e0       	ldi	r22, 0x00	; 0
 2d2:	70 e0       	ldi	r23, 0x00	; 0
 2d4:	28 e0       	ldi	r18, 0x08	; 8
 2d6:	30 e0       	ldi	r19, 0x00	; 0
			}
			else
			{
				manchesterPtr[i + t] &= (255 - (0 << counter));
				--counter;
				manchesterPtr[i + t] |= (1 << counter);
 2d8:	01 e0       	ldi	r16, 0x01	; 1
 2da:	10 e0       	ldi	r17, 0x00	; 0
		{
			--counter;

			if (counter < 0 || counter > 7)
			{
				counter = 7;
 2dc:	0f 2e       	mov	r0, r31
 2de:	f7 e0       	ldi	r31, 0x07	; 7
 2e0:	9f 2e       	mov	r9, r31
 2e2:	f0 2d       	mov	r31, r0
 2e4:	81 2c       	mov	r8, r1
	int counter = 8;
	int t = 0;

	for (int i = 0; i < len; ++i)
	{
		unsigned char ch = toBeConverted[i];
 2e6:	f7 01       	movw	r30, r14
 2e8:	c1 91       	ld	r28, Z+
 2ea:	7f 01       	movw	r14, r30

		for (int j = 7; j >= 0; j--)
 2ec:	47 e0       	ldi	r20, 0x07	; 7
 2ee:	50 e0       	ldi	r21, 0x00	; 0
			if (counter < 0 || counter > 7)
			{
				counter = 7;
				++t;
			}
			if (ch & (1 << j))
 2f0:	d0 e0       	ldi	r29, 0x00	; 0
	{
		unsigned char ch = toBeConverted[i];

		for (int j = 7; j >= 0; j--)
		{
			--counter;
 2f2:	21 50       	subi	r18, 0x01	; 1
 2f4:	31 09       	sbc	r19, r1

			if (counter < 0 || counter > 7)
 2f6:	28 30       	cpi	r18, 0x08	; 8
 2f8:	31 05       	cpc	r19, r1
 2fa:	20 f0       	brcs	.+8      	; 0x304 <stringToManchester+0x8c>
			{
				counter = 7;
				++t;
 2fc:	6f 5f       	subi	r22, 0xFF	; 255
 2fe:	7f 4f       	sbci	r23, 0xFF	; 255
		{
			--counter;

			if (counter < 0 || counter > 7)
			{
				counter = 7;
 300:	29 2d       	mov	r18, r9
 302:	38 2d       	mov	r19, r8
				++t;
			}
			if (ch & (1 << j))
 304:	fe 01       	movw	r30, r28
 306:	04 2e       	mov	r0, r20
 308:	02 c0       	rjmp	.+4      	; 0x30e <stringToManchester+0x96>
 30a:	f5 95       	asr	r31
 30c:	e7 95       	ror	r30
 30e:	0a 94       	dec	r0
 310:	e2 f7       	brpl	.-8      	; 0x30a <stringToManchester+0x92>
 312:	e0 ff       	sbrs	r30, 0
 314:	12 c0       	rjmp	.+36     	; 0x33a <stringToManchester+0xc2>
			{
				manchesterPtr[i + t] |= 1 << counter;
 316:	fb 01       	movw	r30, r22
 318:	ea 0f       	add	r30, r26
 31a:	fb 1f       	adc	r31, r27
 31c:	e8 0f       	add	r30, r24
 31e:	f9 1f       	adc	r31, r25
 320:	68 01       	movw	r12, r16
 322:	02 2e       	mov	r0, r18
 324:	02 c0       	rjmp	.+4      	; 0x32a <stringToManchester+0xb2>
 326:	cc 0c       	add	r12, r12
 328:	dd 1c       	adc	r13, r13
 32a:	0a 94       	dec	r0
 32c:	e2 f7       	brpl	.-8      	; 0x326 <stringToManchester+0xae>
 32e:	d0 80       	ld	r13, Z
 330:	cd 28       	or	r12, r13
 332:	c0 82       	st	Z, r12
				--counter;
 334:	21 50       	subi	r18, 0x01	; 1
 336:	31 09       	sbc	r19, r1
 338:	11 c0       	rjmp	.+34     	; 0x35c <stringToManchester+0xe4>
				manchesterPtr[i + t] &= (255 - (0 << counter));
			}
			else
			{
				manchesterPtr[i + t] &= (255 - (0 << counter));
 33a:	fb 01       	movw	r30, r22
 33c:	ea 0f       	add	r30, r26
 33e:	fb 1f       	adc	r31, r27
 340:	e8 0f       	add	r30, r24
 342:	f9 1f       	adc	r31, r25
				--counter;
 344:	21 50       	subi	r18, 0x01	; 1
 346:	31 09       	sbc	r19, r1
				manchesterPtr[i + t] |= (1 << counter);
 348:	68 01       	movw	r12, r16
 34a:	02 2e       	mov	r0, r18
 34c:	02 c0       	rjmp	.+4      	; 0x352 <stringToManchester+0xda>
 34e:	cc 0c       	add	r12, r12
 350:	dd 1c       	adc	r13, r13
 352:	0a 94       	dec	r0
 354:	e2 f7       	brpl	.-8      	; 0x34e <stringToManchester+0xd6>
 356:	d0 80       	ld	r13, Z
 358:	cd 28       	or	r12, r13
 35a:	c0 82       	st	Z, r12

	for (int i = 0; i < len; ++i)
	{
		unsigned char ch = toBeConverted[i];

		for (int j = 7; j >= 0; j--)
 35c:	41 50       	subi	r20, 0x01	; 1
 35e:	51 09       	sbc	r21, r1
 360:	40 f6       	brcc	.-112    	; 0x2f2 <stringToManchester+0x7a>
				manchesterPtr[i + t] &= (255 - (0 << counter));
				--counter;
				manchesterPtr[i + t] |= (1 << counter);
			}
		}
		--t;															// Find næste character i array af chars som skal konverteres.
 362:	61 50       	subi	r22, 0x01	; 1
 364:	71 09       	sbc	r23, r1
	int len = strlen((char*)toBeConverted);											// Lav size_t som kan passes til calloc.
	manchesterPtr = (unsigned char *)calloc((((len+1) * 2) + 1), 1);				// Alloker hukommelse
	int counter = 8;
	int t = 0;

	for (int i = 0; i < len; ++i)
 366:	11 96       	adiw	r26, 0x01	; 1
 368:	aa 16       	cp	r10, r26
 36a:	bb 06       	cpc	r11, r27
 36c:	09 f0       	breq	.+2      	; 0x370 <stringToManchester+0xf8>
 36e:	bb cf       	rjmp	.-138    	; 0x2e6 <stringToManchester+0x6e>
 370:	02 c0       	rjmp	.+4      	; 0x376 <stringToManchester+0xfe>
	free(manchesterPtr);
}

unsigned char* stringToManchester(unsigned char* toBeConverted)
{
	if (toBeConverted == (unsigned char*)"") return 0;						// Hvis der ikke er input, return 0 
 372:	80 e0       	ldi	r24, 0x00	; 0
 374:	90 e0       	ldi	r25, 0x00	; 0
			}
		}
		--t;															// Find næste character i array af chars som skal konverteres.
	}
	return manchesterPtr;													// Returnér manchesterkoden
}
 376:	df 91       	pop	r29
 378:	cf 91       	pop	r28
 37a:	1f 91       	pop	r17
 37c:	0f 91       	pop	r16
 37e:	ff 90       	pop	r15
 380:	ef 90       	pop	r14
 382:	df 90       	pop	r13
 384:	cf 90       	pop	r12
 386:	bf 90       	pop	r11
 388:	af 90       	pop	r10
 38a:	9f 90       	pop	r9
 38c:	8f 90       	pop	r8
 38e:	08 95       	ret

00000390 <initSensor>:
static char register_;
static short int pin_;

void initSensor(char register__, short int pin)
{
	if (register__ > 'L' || register__ < 'A' || register__ == 'I')
 390:	9f eb       	ldi	r25, 0xBF	; 191
 392:	98 0f       	add	r25, r24
 394:	9c 30       	cpi	r25, 0x0C	; 12
 396:	10 f4       	brcc	.+4      	; 0x39c <initSensor+0xc>
 398:	89 34       	cpi	r24, 0x49	; 73
 39a:	39 f4       	brne	.+14     	; 0x3aa <initSensor+0x1a>
	{
		register_ = 'A';
 39c:	81 e4       	ldi	r24, 0x41	; 65
 39e:	80 93 10 02 	sts	0x0210, r24	; 0x800210 <register_>
	}
	if (pin > 7)
 3a2:	68 30       	cpi	r22, 0x08	; 8
 3a4:	71 05       	cpc	r23, r1
 3a6:	24 f4       	brge	.+8      	; 0x3b0 <initSensor+0x20>
 3a8:	19 c0       	rjmp	.+50     	; 0x3dc <initSensor+0x4c>
 3aa:	68 30       	cpi	r22, 0x08	; 8
 3ac:	71 05       	cpc	r23, r1
 3ae:	34 f0       	brlt	.+12     	; 0x3bc <initSensor+0x2c>
	{
		pin_ = 2;
 3b0:	82 e0       	ldi	r24, 0x02	; 2
 3b2:	90 e0       	ldi	r25, 0x00	; 0
 3b4:	90 93 0f 02 	sts	0x020F, r25	; 0x80020f <pin_+0x1>
 3b8:	80 93 0e 02 	sts	0x020E, r24	; 0x80020e <pin_>
	}

	switch (register_)
 3bc:	e0 91 10 02 	lds	r30, 0x0210	; 0x800210 <register_>
 3c0:	8e 2f       	mov	r24, r30
 3c2:	90 e0       	ldi	r25, 0x00	; 0
 3c4:	fc 01       	movw	r30, r24
 3c6:	e1 54       	subi	r30, 0x41	; 65
 3c8:	f1 09       	sbc	r31, r1
 3ca:	ec 30       	cpi	r30, 0x0C	; 12
 3cc:	f1 05       	cpc	r31, r1
 3ce:	08 f0       	brcs	.+2      	; 0x3d2 <initSensor+0x42>
 3d0:	a6 c0       	rjmp	.+332    	; 0x51e <__LOCK_REGION_LENGTH__+0x11e>
 3d2:	88 27       	eor	r24, r24
 3d4:	ee 58       	subi	r30, 0x8E	; 142
 3d6:	ff 4f       	sbci	r31, 0xFF	; 255
 3d8:	8f 4f       	sbci	r24, 0xFF	; 255
 3da:	96 c2       	rjmp	.+1324   	; 0x908 <__tablejump2__>
	{
		case 'A':
		DDRA &= ~(1 << pin_);
 3dc:	21 b1       	in	r18, 0x01	; 1
 3de:	81 e0       	ldi	r24, 0x01	; 1
 3e0:	90 e0       	ldi	r25, 0x00	; 0
 3e2:	00 90 0e 02 	lds	r0, 0x020E	; 0x80020e <pin_>
 3e6:	02 c0       	rjmp	.+4      	; 0x3ec <initSensor+0x5c>
 3e8:	88 0f       	add	r24, r24
 3ea:	99 1f       	adc	r25, r25
 3ec:	0a 94       	dec	r0
 3ee:	e2 f7       	brpl	.-8      	; 0x3e8 <initSensor+0x58>
 3f0:	80 95       	com	r24
 3f2:	82 23       	and	r24, r18
 3f4:	81 b9       	out	0x01, r24	; 1
		break;
 3f6:	08 95       	ret
		case 'B':
		DDRB &= ~(1 << pin_);
 3f8:	24 b1       	in	r18, 0x04	; 4
 3fa:	81 e0       	ldi	r24, 0x01	; 1
 3fc:	90 e0       	ldi	r25, 0x00	; 0
 3fe:	00 90 0e 02 	lds	r0, 0x020E	; 0x80020e <pin_>
 402:	02 c0       	rjmp	.+4      	; 0x408 <__LOCK_REGION_LENGTH__+0x8>
 404:	88 0f       	add	r24, r24
 406:	99 1f       	adc	r25, r25
 408:	0a 94       	dec	r0
 40a:	e2 f7       	brpl	.-8      	; 0x404 <__LOCK_REGION_LENGTH__+0x4>
 40c:	80 95       	com	r24
 40e:	82 23       	and	r24, r18
 410:	84 b9       	out	0x04, r24	; 4
		break;
 412:	08 95       	ret
		case 'C':
		DDRC &= ~(1 << pin_);
 414:	27 b1       	in	r18, 0x07	; 7
 416:	81 e0       	ldi	r24, 0x01	; 1
 418:	90 e0       	ldi	r25, 0x00	; 0
 41a:	00 90 0e 02 	lds	r0, 0x020E	; 0x80020e <pin_>
 41e:	02 c0       	rjmp	.+4      	; 0x424 <__LOCK_REGION_LENGTH__+0x24>
 420:	88 0f       	add	r24, r24
 422:	99 1f       	adc	r25, r25
 424:	0a 94       	dec	r0
 426:	e2 f7       	brpl	.-8      	; 0x420 <__LOCK_REGION_LENGTH__+0x20>
 428:	80 95       	com	r24
 42a:	82 23       	and	r24, r18
 42c:	87 b9       	out	0x07, r24	; 7
		break;
 42e:	08 95       	ret
		case 'D':
		DDRD &= ~(1 << pin_);
 430:	2a b1       	in	r18, 0x0a	; 10
 432:	81 e0       	ldi	r24, 0x01	; 1
 434:	90 e0       	ldi	r25, 0x00	; 0
 436:	00 90 0e 02 	lds	r0, 0x020E	; 0x80020e <pin_>
 43a:	02 c0       	rjmp	.+4      	; 0x440 <__LOCK_REGION_LENGTH__+0x40>
 43c:	88 0f       	add	r24, r24
 43e:	99 1f       	adc	r25, r25
 440:	0a 94       	dec	r0
 442:	e2 f7       	brpl	.-8      	; 0x43c <__LOCK_REGION_LENGTH__+0x3c>
 444:	80 95       	com	r24
 446:	82 23       	and	r24, r18
 448:	8a b9       	out	0x0a, r24	; 10
		break;
 44a:	08 95       	ret
		case 'E':
		DDRE &= ~(1 << pin_);
 44c:	2d b1       	in	r18, 0x0d	; 13
 44e:	81 e0       	ldi	r24, 0x01	; 1
 450:	90 e0       	ldi	r25, 0x00	; 0
 452:	00 90 0e 02 	lds	r0, 0x020E	; 0x80020e <pin_>
 456:	02 c0       	rjmp	.+4      	; 0x45c <__LOCK_REGION_LENGTH__+0x5c>
 458:	88 0f       	add	r24, r24
 45a:	99 1f       	adc	r25, r25
 45c:	0a 94       	dec	r0
 45e:	e2 f7       	brpl	.-8      	; 0x458 <__LOCK_REGION_LENGTH__+0x58>
 460:	80 95       	com	r24
 462:	82 23       	and	r24, r18
 464:	8d b9       	out	0x0d, r24	; 13
		break;
 466:	08 95       	ret
		case 'F':
		DDRF &= ~(1 << pin_);
 468:	20 b3       	in	r18, 0x10	; 16
 46a:	81 e0       	ldi	r24, 0x01	; 1
 46c:	90 e0       	ldi	r25, 0x00	; 0
 46e:	00 90 0e 02 	lds	r0, 0x020E	; 0x80020e <pin_>
 472:	02 c0       	rjmp	.+4      	; 0x478 <__LOCK_REGION_LENGTH__+0x78>
 474:	88 0f       	add	r24, r24
 476:	99 1f       	adc	r25, r25
 478:	0a 94       	dec	r0
 47a:	e2 f7       	brpl	.-8      	; 0x474 <__LOCK_REGION_LENGTH__+0x74>
 47c:	80 95       	com	r24
 47e:	82 23       	and	r24, r18
 480:	80 bb       	out	0x10, r24	; 16
		break;
 482:	08 95       	ret
		case 'G':
		DDRG &= ~(1 << pin_);
 484:	23 b3       	in	r18, 0x13	; 19
 486:	81 e0       	ldi	r24, 0x01	; 1
 488:	90 e0       	ldi	r25, 0x00	; 0
 48a:	00 90 0e 02 	lds	r0, 0x020E	; 0x80020e <pin_>
 48e:	02 c0       	rjmp	.+4      	; 0x494 <__LOCK_REGION_LENGTH__+0x94>
 490:	88 0f       	add	r24, r24
 492:	99 1f       	adc	r25, r25
 494:	0a 94       	dec	r0
 496:	e2 f7       	brpl	.-8      	; 0x490 <__LOCK_REGION_LENGTH__+0x90>
 498:	80 95       	com	r24
 49a:	82 23       	and	r24, r18
 49c:	83 bb       	out	0x13, r24	; 19
		break;
 49e:	08 95       	ret
		case 'H':
		DDRH &= ~(1 << pin_);
 4a0:	e1 e0       	ldi	r30, 0x01	; 1
 4a2:	f1 e0       	ldi	r31, 0x01	; 1
 4a4:	20 81       	ld	r18, Z
 4a6:	81 e0       	ldi	r24, 0x01	; 1
 4a8:	90 e0       	ldi	r25, 0x00	; 0
 4aa:	00 90 0e 02 	lds	r0, 0x020E	; 0x80020e <pin_>
 4ae:	02 c0       	rjmp	.+4      	; 0x4b4 <__LOCK_REGION_LENGTH__+0xb4>
 4b0:	88 0f       	add	r24, r24
 4b2:	99 1f       	adc	r25, r25
 4b4:	0a 94       	dec	r0
 4b6:	e2 f7       	brpl	.-8      	; 0x4b0 <__LOCK_REGION_LENGTH__+0xb0>
 4b8:	80 95       	com	r24
 4ba:	82 23       	and	r24, r18
 4bc:	80 83       	st	Z, r24
		break;
 4be:	08 95       	ret
		case 'J':
		DDRJ &= ~(1 << pin_);
 4c0:	e4 e0       	ldi	r30, 0x04	; 4
 4c2:	f1 e0       	ldi	r31, 0x01	; 1
 4c4:	20 81       	ld	r18, Z
 4c6:	81 e0       	ldi	r24, 0x01	; 1
 4c8:	90 e0       	ldi	r25, 0x00	; 0
 4ca:	00 90 0e 02 	lds	r0, 0x020E	; 0x80020e <pin_>
 4ce:	02 c0       	rjmp	.+4      	; 0x4d4 <__LOCK_REGION_LENGTH__+0xd4>
 4d0:	88 0f       	add	r24, r24
 4d2:	99 1f       	adc	r25, r25
 4d4:	0a 94       	dec	r0
 4d6:	e2 f7       	brpl	.-8      	; 0x4d0 <__LOCK_REGION_LENGTH__+0xd0>
 4d8:	80 95       	com	r24
 4da:	82 23       	and	r24, r18
 4dc:	80 83       	st	Z, r24
		break;
 4de:	08 95       	ret
		case 'K':
		DDRK &= ~(1 << pin_);
 4e0:	e7 e0       	ldi	r30, 0x07	; 7
 4e2:	f1 e0       	ldi	r31, 0x01	; 1
 4e4:	20 81       	ld	r18, Z
 4e6:	81 e0       	ldi	r24, 0x01	; 1
 4e8:	90 e0       	ldi	r25, 0x00	; 0
 4ea:	00 90 0e 02 	lds	r0, 0x020E	; 0x80020e <pin_>
 4ee:	02 c0       	rjmp	.+4      	; 0x4f4 <__LOCK_REGION_LENGTH__+0xf4>
 4f0:	88 0f       	add	r24, r24
 4f2:	99 1f       	adc	r25, r25
 4f4:	0a 94       	dec	r0
 4f6:	e2 f7       	brpl	.-8      	; 0x4f0 <__LOCK_REGION_LENGTH__+0xf0>
 4f8:	80 95       	com	r24
 4fa:	82 23       	and	r24, r18
 4fc:	80 83       	st	Z, r24
		break;
 4fe:	08 95       	ret
		case 'L':
		DDRL &= ~(1 << pin_);
 500:	ea e0       	ldi	r30, 0x0A	; 10
 502:	f1 e0       	ldi	r31, 0x01	; 1
 504:	20 81       	ld	r18, Z
 506:	81 e0       	ldi	r24, 0x01	; 1
 508:	90 e0       	ldi	r25, 0x00	; 0
 50a:	00 90 0e 02 	lds	r0, 0x020E	; 0x80020e <pin_>
 50e:	02 c0       	rjmp	.+4      	; 0x514 <__LOCK_REGION_LENGTH__+0x114>
 510:	88 0f       	add	r24, r24
 512:	99 1f       	adc	r25, r25
 514:	0a 94       	dec	r0
 516:	e2 f7       	brpl	.-8      	; 0x510 <__LOCK_REGION_LENGTH__+0x110>
 518:	80 95       	com	r24
 51a:	82 23       	and	r24, r18
 51c:	80 83       	st	Z, r24
 51e:	08 95       	ret

00000520 <resetTimer>:
	  // Timer1: Normal mode, PS = 1024
	  TCCR1A = 0b00000000;
	  TCCR1B = 0b00000101;
	  // Enable Timer1 overflow interrupt
	  TCNT1 = (0xFFFF-15625);
	  TIMSK1 |= 0b00000001;
 520:	80 e3       	ldi	r24, 0x30	; 48
 522:	90 e0       	ldi	r25, 0x00	; 0
 524:	90 93 12 02 	sts	0x0212, r25	; 0x800212 <timerStatus_+0x1>
 528:	80 93 11 02 	sts	0x0211, r24	; 0x800211 <timerStatus_>
 52c:	10 92 14 02 	sts	0x0214, r1	; 0x800214 <ctr_+0x1>
 530:	10 92 13 02 	sts	0x0213, r1	; 0x800213 <ctr_>
 534:	08 95       	ret

00000536 <__vector_20>:
	  
}

 ISR(TIMER1_OVF_vect)
 {
 536:	1f 92       	push	r1
 538:	0f 92       	push	r0
 53a:	0f b6       	in	r0, 0x3f	; 63
 53c:	0f 92       	push	r0
 53e:	11 24       	eor	r1, r1
 540:	0b b6       	in	r0, 0x3b	; 59
 542:	0f 92       	push	r0
 544:	2f 93       	push	r18
 546:	3f 93       	push	r19
 548:	4f 93       	push	r20
 54a:	5f 93       	push	r21
 54c:	6f 93       	push	r22
 54e:	7f 93       	push	r23
 550:	8f 93       	push	r24
 552:	9f 93       	push	r25
 554:	af 93       	push	r26
 556:	bf 93       	push	r27
 558:	ef 93       	push	r30
 55a:	ff 93       	push	r31
	 // Tæller ctr_ op hvert sekund.
	 ctr_++;
 55c:	80 91 13 02 	lds	r24, 0x0213	; 0x800213 <ctr_>
 560:	90 91 14 02 	lds	r25, 0x0214	; 0x800214 <ctr_+0x1>
 564:	01 96       	adiw	r24, 0x01	; 1
 566:	90 93 14 02 	sts	0x0214, r25	; 0x800214 <ctr_+0x1>
 56a:	80 93 13 02 	sts	0x0213, r24	; 0x800213 <ctr_>
	 //	sætter tcnt1 til krævet værdi for 1s delay
	 TCNT1 = (0xFFFF-15625);
 56e:	86 ef       	ldi	r24, 0xF6	; 246
 570:	92 ec       	ldi	r25, 0xC2	; 194
 572:	90 93 85 00 	sts	0x0085, r25	; 0x800085 <__TEXT_REGION_LENGTH__+0x700085>
 576:	80 93 84 00 	sts	0x0084, r24	; 0x800084 <__TEXT_REGION_LENGTH__+0x700084>

	 if (ctr_ == 600) //overflow 1 gang i sekundet betyder 600 = 10 min.	 
 57a:	80 91 13 02 	lds	r24, 0x0213	; 0x800213 <ctr_>
 57e:	90 91 14 02 	lds	r25, 0x0214	; 0x800214 <ctr_+0x1>
 582:	88 35       	cpi	r24, 0x58	; 88
 584:	92 40       	sbci	r25, 0x02	; 2
	 {
		resetTimer();
 586:	29 f4       	brne	.+10     	; 0x592 <__vector_20+0x5c>
		TIMSK1 &= 0;
 588:	cb df       	rcall	.-106    	; 0x520 <resetTimer>
 58a:	ef e6       	ldi	r30, 0x6F	; 111
 58c:	f0 e0       	ldi	r31, 0x00	; 0
 58e:	80 81       	ld	r24, Z
	 }
 590:	10 82       	st	Z, r1
 592:	ff 91       	pop	r31
 594:	ef 91       	pop	r30
 596:	bf 91       	pop	r27
 598:	af 91       	pop	r26
 59a:	9f 91       	pop	r25
 59c:	8f 91       	pop	r24
 59e:	7f 91       	pop	r23
 5a0:	6f 91       	pop	r22
 5a2:	5f 91       	pop	r21
 5a4:	4f 91       	pop	r20
 5a6:	3f 91       	pop	r19
 5a8:	2f 91       	pop	r18
 5aa:	0f 90       	pop	r0
 5ac:	0b be       	out	0x3b, r0	; 59
 5ae:	0f 90       	pop	r0
 5b0:	0f be       	out	0x3f, r0	; 63
 5b2:	0f 90       	pop	r0
 5b4:	1f 90       	pop	r1
 5b6:	18 95       	reti

000005b8 <initToggleSwitch>:
static char register_;
static short int pin_;

void initToggleSwitch(char register__, short int pin)
{
 	if (register__ > 'L' || register__ < 'A' || register__ == 'I')
 5b8:	9f eb       	ldi	r25, 0xBF	; 191
 5ba:	98 0f       	add	r25, r24
 5bc:	9c 30       	cpi	r25, 0x0C	; 12
 5be:	10 f4       	brcc	.+4      	; 0x5c4 <initToggleSwitch+0xc>
 5c0:	89 34       	cpi	r24, 0x49	; 73
 5c2:	21 f4       	brne	.+8      	; 0x5cc <initToggleSwitch+0x14>
 	{
	 	register_ = 'A';
 5c4:	81 e4       	ldi	r24, 0x41	; 65
 5c6:	80 93 17 02 	sts	0x0217, r24	; 0x800217 <register_>
 5ca:	02 c0       	rjmp	.+4      	; 0x5d0 <initToggleSwitch+0x18>
 	}
	else
	{
		register_ = register__;
 5cc:	80 93 17 02 	sts	0x0217, r24	; 0x800217 <register_>
	}
 	if (pin > 7)
 5d0:	68 30       	cpi	r22, 0x08	; 8
 5d2:	71 05       	cpc	r23, r1
 5d4:	3c f0       	brlt	.+14     	; 0x5e4 <initToggleSwitch+0x2c>
 	{
	 	pin_ = 1;
 5d6:	81 e0       	ldi	r24, 0x01	; 1
 5d8:	90 e0       	ldi	r25, 0x00	; 0
 5da:	90 93 16 02 	sts	0x0216, r25	; 0x800216 <pin_+0x1>
 5de:	80 93 15 02 	sts	0x0215, r24	; 0x800215 <pin_>
 5e2:	04 c0       	rjmp	.+8      	; 0x5ec <initToggleSwitch+0x34>
 	}
	else
	{
		pin_ = pin;
 5e4:	70 93 16 02 	sts	0x0216, r23	; 0x800216 <pin_+0x1>
 5e8:	60 93 15 02 	sts	0x0215, r22	; 0x800215 <pin_>
	}
 	
 	switch (register_)
 5ec:	e0 91 17 02 	lds	r30, 0x0217	; 0x800217 <register_>
 5f0:	8e 2f       	mov	r24, r30
 5f2:	90 e0       	ldi	r25, 0x00	; 0
 5f4:	fc 01       	movw	r30, r24
 5f6:	e1 54       	subi	r30, 0x41	; 65
 5f8:	f1 09       	sbc	r31, r1
 5fa:	ec 30       	cpi	r30, 0x0C	; 12
 5fc:	f1 05       	cpc	r31, r1
 5fe:	08 f0       	brcs	.+2      	; 0x602 <initToggleSwitch+0x4a>
 600:	a6 c0       	rjmp	.+332    	; 0x74e <initToggleSwitch+0x196>
 602:	88 27       	eor	r24, r24
 604:	e2 58       	subi	r30, 0x82	; 130
 606:	ff 4f       	sbci	r31, 0xFF	; 255
 608:	8f 4f       	sbci	r24, 0xFF	; 255
 60a:	7e c1       	rjmp	.+764    	; 0x908 <__tablejump2__>
 	{
	 	case 'A':
	 	DDRA &= ~(1 << pin_);
 60c:	21 b1       	in	r18, 0x01	; 1
 60e:	81 e0       	ldi	r24, 0x01	; 1
 610:	90 e0       	ldi	r25, 0x00	; 0
 612:	00 90 15 02 	lds	r0, 0x0215	; 0x800215 <pin_>
 616:	02 c0       	rjmp	.+4      	; 0x61c <initToggleSwitch+0x64>
 618:	88 0f       	add	r24, r24
 61a:	99 1f       	adc	r25, r25
 61c:	0a 94       	dec	r0
 61e:	e2 f7       	brpl	.-8      	; 0x618 <initToggleSwitch+0x60>
 620:	80 95       	com	r24
 622:	82 23       	and	r24, r18
 624:	81 b9       	out	0x01, r24	; 1
	 	break;
 626:	08 95       	ret
	 	case 'B':
	 	DDRB &= ~(1 << pin_);
 628:	24 b1       	in	r18, 0x04	; 4
 62a:	81 e0       	ldi	r24, 0x01	; 1
 62c:	90 e0       	ldi	r25, 0x00	; 0
 62e:	00 90 15 02 	lds	r0, 0x0215	; 0x800215 <pin_>
 632:	02 c0       	rjmp	.+4      	; 0x638 <initToggleSwitch+0x80>
 634:	88 0f       	add	r24, r24
 636:	99 1f       	adc	r25, r25
 638:	0a 94       	dec	r0
 63a:	e2 f7       	brpl	.-8      	; 0x634 <initToggleSwitch+0x7c>
 63c:	80 95       	com	r24
 63e:	82 23       	and	r24, r18
 640:	84 b9       	out	0x04, r24	; 4
	 	break;
 642:	08 95       	ret
	 	case 'C':
	 	DDRC &= ~(1 << pin_);
 644:	27 b1       	in	r18, 0x07	; 7
 646:	81 e0       	ldi	r24, 0x01	; 1
 648:	90 e0       	ldi	r25, 0x00	; 0
 64a:	00 90 15 02 	lds	r0, 0x0215	; 0x800215 <pin_>
 64e:	02 c0       	rjmp	.+4      	; 0x654 <initToggleSwitch+0x9c>
 650:	88 0f       	add	r24, r24
 652:	99 1f       	adc	r25, r25
 654:	0a 94       	dec	r0
 656:	e2 f7       	brpl	.-8      	; 0x650 <initToggleSwitch+0x98>
 658:	80 95       	com	r24
 65a:	82 23       	and	r24, r18
 65c:	87 b9       	out	0x07, r24	; 7
	 	break;
 65e:	08 95       	ret
	 	case 'D':
	 	DDRD &= ~(1 << pin_);
 660:	2a b1       	in	r18, 0x0a	; 10
 662:	81 e0       	ldi	r24, 0x01	; 1
 664:	90 e0       	ldi	r25, 0x00	; 0
 666:	00 90 15 02 	lds	r0, 0x0215	; 0x800215 <pin_>
 66a:	02 c0       	rjmp	.+4      	; 0x670 <initToggleSwitch+0xb8>
 66c:	88 0f       	add	r24, r24
 66e:	99 1f       	adc	r25, r25
 670:	0a 94       	dec	r0
 672:	e2 f7       	brpl	.-8      	; 0x66c <initToggleSwitch+0xb4>
 674:	80 95       	com	r24
 676:	82 23       	and	r24, r18
 678:	8a b9       	out	0x0a, r24	; 10
	 	break;
 67a:	08 95       	ret
	 	case 'E':
	 	DDRE &= ~(1 << pin_);
 67c:	2d b1       	in	r18, 0x0d	; 13
 67e:	81 e0       	ldi	r24, 0x01	; 1
 680:	90 e0       	ldi	r25, 0x00	; 0
 682:	00 90 15 02 	lds	r0, 0x0215	; 0x800215 <pin_>
 686:	02 c0       	rjmp	.+4      	; 0x68c <initToggleSwitch+0xd4>
 688:	88 0f       	add	r24, r24
 68a:	99 1f       	adc	r25, r25
 68c:	0a 94       	dec	r0
 68e:	e2 f7       	brpl	.-8      	; 0x688 <initToggleSwitch+0xd0>
 690:	80 95       	com	r24
 692:	82 23       	and	r24, r18
 694:	8d b9       	out	0x0d, r24	; 13
	 	break;
 696:	08 95       	ret
	 	case 'F':
	 	DDRF &= ~(1 << pin_);
 698:	20 b3       	in	r18, 0x10	; 16
 69a:	81 e0       	ldi	r24, 0x01	; 1
 69c:	90 e0       	ldi	r25, 0x00	; 0
 69e:	00 90 15 02 	lds	r0, 0x0215	; 0x800215 <pin_>
 6a2:	02 c0       	rjmp	.+4      	; 0x6a8 <initToggleSwitch+0xf0>
 6a4:	88 0f       	add	r24, r24
 6a6:	99 1f       	adc	r25, r25
 6a8:	0a 94       	dec	r0
 6aa:	e2 f7       	brpl	.-8      	; 0x6a4 <initToggleSwitch+0xec>
 6ac:	80 95       	com	r24
 6ae:	82 23       	and	r24, r18
 6b0:	80 bb       	out	0x10, r24	; 16
	 	break;
 6b2:	08 95       	ret
	 	case 'G':
	 	DDRG &= ~(1 << pin_);
 6b4:	23 b3       	in	r18, 0x13	; 19
 6b6:	81 e0       	ldi	r24, 0x01	; 1
 6b8:	90 e0       	ldi	r25, 0x00	; 0
 6ba:	00 90 15 02 	lds	r0, 0x0215	; 0x800215 <pin_>
 6be:	02 c0       	rjmp	.+4      	; 0x6c4 <initToggleSwitch+0x10c>
 6c0:	88 0f       	add	r24, r24
 6c2:	99 1f       	adc	r25, r25
 6c4:	0a 94       	dec	r0
 6c6:	e2 f7       	brpl	.-8      	; 0x6c0 <initToggleSwitch+0x108>
 6c8:	80 95       	com	r24
 6ca:	82 23       	and	r24, r18
 6cc:	83 bb       	out	0x13, r24	; 19
	 	break;
 6ce:	08 95       	ret
	 	case 'H':
	 	DDRH &= ~(1 << pin_);
 6d0:	e1 e0       	ldi	r30, 0x01	; 1
 6d2:	f1 e0       	ldi	r31, 0x01	; 1
 6d4:	20 81       	ld	r18, Z
 6d6:	81 e0       	ldi	r24, 0x01	; 1
 6d8:	90 e0       	ldi	r25, 0x00	; 0
 6da:	00 90 15 02 	lds	r0, 0x0215	; 0x800215 <pin_>
 6de:	02 c0       	rjmp	.+4      	; 0x6e4 <initToggleSwitch+0x12c>
 6e0:	88 0f       	add	r24, r24
 6e2:	99 1f       	adc	r25, r25
 6e4:	0a 94       	dec	r0
 6e6:	e2 f7       	brpl	.-8      	; 0x6e0 <initToggleSwitch+0x128>
 6e8:	80 95       	com	r24
 6ea:	82 23       	and	r24, r18
 6ec:	80 83       	st	Z, r24
	 	break;
 6ee:	08 95       	ret
	 	case 'J':
	 	DDRJ &= ~(1 << pin_);
 6f0:	e4 e0       	ldi	r30, 0x04	; 4
 6f2:	f1 e0       	ldi	r31, 0x01	; 1
 6f4:	20 81       	ld	r18, Z
 6f6:	81 e0       	ldi	r24, 0x01	; 1
 6f8:	90 e0       	ldi	r25, 0x00	; 0
 6fa:	00 90 15 02 	lds	r0, 0x0215	; 0x800215 <pin_>
 6fe:	02 c0       	rjmp	.+4      	; 0x704 <initToggleSwitch+0x14c>
 700:	88 0f       	add	r24, r24
 702:	99 1f       	adc	r25, r25
 704:	0a 94       	dec	r0
 706:	e2 f7       	brpl	.-8      	; 0x700 <initToggleSwitch+0x148>
 708:	80 95       	com	r24
 70a:	82 23       	and	r24, r18
 70c:	80 83       	st	Z, r24
	 	break;
 70e:	08 95       	ret
	 	case 'K':
	 	DDRK &= ~(1 << pin_);
 710:	e7 e0       	ldi	r30, 0x07	; 7
 712:	f1 e0       	ldi	r31, 0x01	; 1
 714:	20 81       	ld	r18, Z
 716:	81 e0       	ldi	r24, 0x01	; 1
 718:	90 e0       	ldi	r25, 0x00	; 0
 71a:	00 90 15 02 	lds	r0, 0x0215	; 0x800215 <pin_>
 71e:	02 c0       	rjmp	.+4      	; 0x724 <initToggleSwitch+0x16c>
 720:	88 0f       	add	r24, r24
 722:	99 1f       	adc	r25, r25
 724:	0a 94       	dec	r0
 726:	e2 f7       	brpl	.-8      	; 0x720 <initToggleSwitch+0x168>
 728:	80 95       	com	r24
 72a:	82 23       	and	r24, r18
 72c:	80 83       	st	Z, r24
	 	break;
 72e:	08 95       	ret
	 	case 'L':
	 	DDRL &= ~(1 << pin_);
 730:	ea e0       	ldi	r30, 0x0A	; 10
 732:	f1 e0       	ldi	r31, 0x01	; 1
 734:	20 81       	ld	r18, Z
 736:	81 e0       	ldi	r24, 0x01	; 1
 738:	90 e0       	ldi	r25, 0x00	; 0
 73a:	00 90 15 02 	lds	r0, 0x0215	; 0x800215 <pin_>
 73e:	02 c0       	rjmp	.+4      	; 0x744 <initToggleSwitch+0x18c>
 740:	88 0f       	add	r24, r24
 742:	99 1f       	adc	r25, r25
 744:	0a 94       	dec	r0
 746:	e2 f7       	brpl	.-8      	; 0x740 <initToggleSwitch+0x188>
 748:	80 95       	com	r24
 74a:	82 23       	and	r24, r18
 74c:	80 83       	st	Z, r24
 74e:	08 95       	ret

00000750 <initToggleSwitchLED>:
 static char register_;
 static short int pin_;

 void initToggleSwitchLED(char register__, short int pin)
 {
	if (register__ > 'L' || register__ < 'A' || register__ == 'I')
 750:	9f eb       	ldi	r25, 0xBF	; 191
 752:	98 0f       	add	r25, r24
 754:	9c 30       	cpi	r25, 0x0C	; 12
 756:	10 f4       	brcc	.+4      	; 0x75c <initToggleSwitchLED+0xc>
 758:	89 34       	cpi	r24, 0x49	; 73
 75a:	21 f4       	brne	.+8      	; 0x764 <initToggleSwitchLED+0x14>
	{
		register_ = 'A';
 75c:	81 e4       	ldi	r24, 0x41	; 65
 75e:	80 93 1a 02 	sts	0x021A, r24	; 0x80021a <register_>
 762:	02 c0       	rjmp	.+4      	; 0x768 <initToggleSwitchLED+0x18>
	}
	else
	{
		register_ = register__;
 764:	80 93 1a 02 	sts	0x021A, r24	; 0x80021a <register_>
	}
	if (pin > 7 || pin < 0)
 768:	68 30       	cpi	r22, 0x08	; 8
 76a:	71 05       	cpc	r23, r1
 76c:	38 f0       	brcs	.+14     	; 0x77c <initToggleSwitchLED+0x2c>
	{
		pin_ = 1;
 76e:	81 e0       	ldi	r24, 0x01	; 1
 770:	90 e0       	ldi	r25, 0x00	; 0
 772:	90 93 19 02 	sts	0x0219, r25	; 0x800219 <pin_+0x1>
 776:	80 93 18 02 	sts	0x0218, r24	; 0x800218 <pin_>
 77a:	04 c0       	rjmp	.+8      	; 0x784 <initToggleSwitchLED+0x34>
	}
	else
	{
		pin_ = pin;
 77c:	70 93 19 02 	sts	0x0219, r23	; 0x800219 <pin_+0x1>
 780:	60 93 18 02 	sts	0x0218, r22	; 0x800218 <pin_>
	}

	//sæt given pin til output

	switch (register_)
 784:	e0 91 1a 02 	lds	r30, 0x021A	; 0x80021a <register_>
 788:	8e 2f       	mov	r24, r30
 78a:	90 e0       	ldi	r25, 0x00	; 0
 78c:	fc 01       	movw	r30, r24
 78e:	e1 54       	subi	r30, 0x41	; 65
 790:	f1 09       	sbc	r31, r1
 792:	ec 30       	cpi	r30, 0x0C	; 12
 794:	f1 05       	cpc	r31, r1
 796:	08 f0       	brcs	.+2      	; 0x79a <initToggleSwitchLED+0x4a>
 798:	9b c0       	rjmp	.+310    	; 0x8d0 <initToggleSwitchLED+0x180>
 79a:	88 27       	eor	r24, r24
 79c:	e6 57       	subi	r30, 0x76	; 118
 79e:	ff 4f       	sbci	r31, 0xFF	; 255
 7a0:	8f 4f       	sbci	r24, 0xFF	; 255
 7a2:	b2 c0       	rjmp	.+356    	; 0x908 <__tablejump2__>
	{
	case 'A':
	DDRA |= (1 << pin_);
 7a4:	21 b1       	in	r18, 0x01	; 1
 7a6:	81 e0       	ldi	r24, 0x01	; 1
 7a8:	90 e0       	ldi	r25, 0x00	; 0
 7aa:	00 90 18 02 	lds	r0, 0x0218	; 0x800218 <pin_>
 7ae:	02 c0       	rjmp	.+4      	; 0x7b4 <initToggleSwitchLED+0x64>
 7b0:	88 0f       	add	r24, r24
 7b2:	99 1f       	adc	r25, r25
 7b4:	0a 94       	dec	r0
 7b6:	e2 f7       	brpl	.-8      	; 0x7b0 <initToggleSwitchLED+0x60>
 7b8:	82 2b       	or	r24, r18
 7ba:	81 b9       	out	0x01, r24	; 1
	break;
 7bc:	08 95       	ret
	case 'B':
	DDRB |= (1 << pin_);
 7be:	24 b1       	in	r18, 0x04	; 4
 7c0:	81 e0       	ldi	r24, 0x01	; 1
 7c2:	90 e0       	ldi	r25, 0x00	; 0
 7c4:	00 90 18 02 	lds	r0, 0x0218	; 0x800218 <pin_>
 7c8:	02 c0       	rjmp	.+4      	; 0x7ce <initToggleSwitchLED+0x7e>
 7ca:	88 0f       	add	r24, r24
 7cc:	99 1f       	adc	r25, r25
 7ce:	0a 94       	dec	r0
 7d0:	e2 f7       	brpl	.-8      	; 0x7ca <initToggleSwitchLED+0x7a>
 7d2:	82 2b       	or	r24, r18
 7d4:	84 b9       	out	0x04, r24	; 4
	break;
 7d6:	08 95       	ret
	case 'C':
	DDRC |= (1 << pin_);
 7d8:	27 b1       	in	r18, 0x07	; 7
 7da:	81 e0       	ldi	r24, 0x01	; 1
 7dc:	90 e0       	ldi	r25, 0x00	; 0
 7de:	00 90 18 02 	lds	r0, 0x0218	; 0x800218 <pin_>
 7e2:	02 c0       	rjmp	.+4      	; 0x7e8 <initToggleSwitchLED+0x98>
 7e4:	88 0f       	add	r24, r24
 7e6:	99 1f       	adc	r25, r25
 7e8:	0a 94       	dec	r0
 7ea:	e2 f7       	brpl	.-8      	; 0x7e4 <initToggleSwitchLED+0x94>
 7ec:	82 2b       	or	r24, r18
 7ee:	87 b9       	out	0x07, r24	; 7
	break;
 7f0:	08 95       	ret
	case 'D':
	DDRD |= (1 << pin_);
 7f2:	2a b1       	in	r18, 0x0a	; 10
 7f4:	81 e0       	ldi	r24, 0x01	; 1
 7f6:	90 e0       	ldi	r25, 0x00	; 0
 7f8:	00 90 18 02 	lds	r0, 0x0218	; 0x800218 <pin_>
 7fc:	02 c0       	rjmp	.+4      	; 0x802 <initToggleSwitchLED+0xb2>
 7fe:	88 0f       	add	r24, r24
 800:	99 1f       	adc	r25, r25
 802:	0a 94       	dec	r0
 804:	e2 f7       	brpl	.-8      	; 0x7fe <initToggleSwitchLED+0xae>
 806:	82 2b       	or	r24, r18
 808:	8a b9       	out	0x0a, r24	; 10
	break;
 80a:	08 95       	ret
	case 'E':
	DDRE |= (1 << pin_);
 80c:	2d b1       	in	r18, 0x0d	; 13
 80e:	81 e0       	ldi	r24, 0x01	; 1
 810:	90 e0       	ldi	r25, 0x00	; 0
 812:	00 90 18 02 	lds	r0, 0x0218	; 0x800218 <pin_>
 816:	02 c0       	rjmp	.+4      	; 0x81c <initToggleSwitchLED+0xcc>
 818:	88 0f       	add	r24, r24
 81a:	99 1f       	adc	r25, r25
 81c:	0a 94       	dec	r0
 81e:	e2 f7       	brpl	.-8      	; 0x818 <initToggleSwitchLED+0xc8>
 820:	82 2b       	or	r24, r18
 822:	8d b9       	out	0x0d, r24	; 13
	break;
 824:	08 95       	ret
	case 'F':
	DDRF |= (1 << pin_);
 826:	20 b3       	in	r18, 0x10	; 16
 828:	81 e0       	ldi	r24, 0x01	; 1
 82a:	90 e0       	ldi	r25, 0x00	; 0
 82c:	00 90 18 02 	lds	r0, 0x0218	; 0x800218 <pin_>
 830:	02 c0       	rjmp	.+4      	; 0x836 <initToggleSwitchLED+0xe6>
 832:	88 0f       	add	r24, r24
 834:	99 1f       	adc	r25, r25
 836:	0a 94       	dec	r0
 838:	e2 f7       	brpl	.-8      	; 0x832 <initToggleSwitchLED+0xe2>
 83a:	82 2b       	or	r24, r18
 83c:	80 bb       	out	0x10, r24	; 16
	break;
 83e:	08 95       	ret
	case 'G':
	DDRG |= (1 << pin_);
 840:	23 b3       	in	r18, 0x13	; 19
 842:	81 e0       	ldi	r24, 0x01	; 1
 844:	90 e0       	ldi	r25, 0x00	; 0
 846:	00 90 18 02 	lds	r0, 0x0218	; 0x800218 <pin_>
 84a:	02 c0       	rjmp	.+4      	; 0x850 <initToggleSwitchLED+0x100>
 84c:	88 0f       	add	r24, r24
 84e:	99 1f       	adc	r25, r25
 850:	0a 94       	dec	r0
 852:	e2 f7       	brpl	.-8      	; 0x84c <initToggleSwitchLED+0xfc>
 854:	82 2b       	or	r24, r18
 856:	83 bb       	out	0x13, r24	; 19
	break;
 858:	08 95       	ret
	case 'H':
	DDRH |= (1 << pin_);
 85a:	e1 e0       	ldi	r30, 0x01	; 1
 85c:	f1 e0       	ldi	r31, 0x01	; 1
 85e:	20 81       	ld	r18, Z
 860:	81 e0       	ldi	r24, 0x01	; 1
 862:	90 e0       	ldi	r25, 0x00	; 0
 864:	00 90 18 02 	lds	r0, 0x0218	; 0x800218 <pin_>
 868:	02 c0       	rjmp	.+4      	; 0x86e <initToggleSwitchLED+0x11e>
 86a:	88 0f       	add	r24, r24
 86c:	99 1f       	adc	r25, r25
 86e:	0a 94       	dec	r0
 870:	e2 f7       	brpl	.-8      	; 0x86a <initToggleSwitchLED+0x11a>
 872:	82 2b       	or	r24, r18
 874:	80 83       	st	Z, r24
	break;
 876:	08 95       	ret
	case 'J':
	DDRJ |= (1 << pin_);
 878:	e4 e0       	ldi	r30, 0x04	; 4
 87a:	f1 e0       	ldi	r31, 0x01	; 1
 87c:	20 81       	ld	r18, Z
 87e:	81 e0       	ldi	r24, 0x01	; 1
 880:	90 e0       	ldi	r25, 0x00	; 0
 882:	00 90 18 02 	lds	r0, 0x0218	; 0x800218 <pin_>
 886:	02 c0       	rjmp	.+4      	; 0x88c <initToggleSwitchLED+0x13c>
 888:	88 0f       	add	r24, r24
 88a:	99 1f       	adc	r25, r25
 88c:	0a 94       	dec	r0
 88e:	e2 f7       	brpl	.-8      	; 0x888 <initToggleSwitchLED+0x138>
 890:	82 2b       	or	r24, r18
 892:	80 83       	st	Z, r24
	break;
 894:	08 95       	ret
	case 'K':
	DDRK |= (1 << pin_);
 896:	e7 e0       	ldi	r30, 0x07	; 7
 898:	f1 e0       	ldi	r31, 0x01	; 1
 89a:	20 81       	ld	r18, Z
 89c:	81 e0       	ldi	r24, 0x01	; 1
 89e:	90 e0       	ldi	r25, 0x00	; 0
 8a0:	00 90 18 02 	lds	r0, 0x0218	; 0x800218 <pin_>
 8a4:	02 c0       	rjmp	.+4      	; 0x8aa <initToggleSwitchLED+0x15a>
 8a6:	88 0f       	add	r24, r24
 8a8:	99 1f       	adc	r25, r25
 8aa:	0a 94       	dec	r0
 8ac:	e2 f7       	brpl	.-8      	; 0x8a6 <initToggleSwitchLED+0x156>
 8ae:	82 2b       	or	r24, r18
 8b0:	80 83       	st	Z, r24
	break;
 8b2:	08 95       	ret
	case 'L':
	DDRL |= (1 << pin_);
 8b4:	ea e0       	ldi	r30, 0x0A	; 10
 8b6:	f1 e0       	ldi	r31, 0x01	; 1
 8b8:	20 81       	ld	r18, Z
 8ba:	81 e0       	ldi	r24, 0x01	; 1
 8bc:	90 e0       	ldi	r25, 0x00	; 0
 8be:	00 90 18 02 	lds	r0, 0x0218	; 0x800218 <pin_>
 8c2:	02 c0       	rjmp	.+4      	; 0x8c8 <initToggleSwitchLED+0x178>
 8c4:	88 0f       	add	r24, r24
 8c6:	99 1f       	adc	r25, r25
 8c8:	0a 94       	dec	r0
 8ca:	e2 f7       	brpl	.-8      	; 0x8c4 <initToggleSwitchLED+0x174>
 8cc:	82 2b       	or	r24, r18
 8ce:	80 83       	st	Z, r24
 8d0:	08 95       	ret

000008d2 <initZCDetector>:
 void initZCDetector()
 {
	 //------------------------------------//
	 //			 interrupt test			  //
	 //------------------------------------//
	 DDRD &= ~(1 << 0);
 8d2:	50 98       	cbi	0x0a, 0	; 10
	 // PD2 (PCINT0 pin) is now an input
	 PORTD |= (1 << 0);
 8d4:	58 9a       	sbi	0x0b, 0	; 11
	 // PD2 is now an input with pull-up enabled
	 //EICRA |= (1 << ISC11) | (1 << ISC10);   // set INT0 to trigger on ANY logic change
	 EICRA = 0b00000011;
 8d6:	83 e0       	ldi	r24, 0x03	; 3
 8d8:	80 93 69 00 	sts	0x0069, r24	; 0x800069 <__TEXT_REGION_LENGTH__+0x700069>
	 EIMSK |= (1 << 0);
 8dc:	e8 9a       	sbi	0x1d, 0	; 29
 8de:	08 95       	ret

000008e0 <__vector_1>:
	 //------------------------------------//
 }

 // Interrupt service routine for INT0 (Er INT3 for Atmega 2560)
 ISR(INT0_vect)
 {
 8e0:	1f 92       	push	r1
 8e2:	0f 92       	push	r0
 8e4:	0f b6       	in	r0, 0x3f	; 63
 8e6:	0f 92       	push	r0
 8e8:	11 24       	eor	r1, r1
 8ea:	8f 93       	push	r24
 8ec:	9f 93       	push	r25
	 ZCDetected_ = 1;
 8ee:	81 e0       	ldi	r24, 0x01	; 1
 8f0:	90 e0       	ldi	r25, 0x00	; 0
 8f2:	90 93 20 02 	sts	0x0220, r25	; 0x800220 <ZCDetected_+0x1>
 8f6:	80 93 1f 02 	sts	0x021F, r24	; 0x80021f <ZCDetected_>
 8fa:	9f 91       	pop	r25
 8fc:	8f 91       	pop	r24
 8fe:	0f 90       	pop	r0
 900:	0f be       	out	0x3f, r0	; 63
 902:	0f 90       	pop	r0
 904:	1f 90       	pop	r1
 906:	18 95       	reti

00000908 <__tablejump2__>:
 908:	ee 0f       	add	r30, r30
 90a:	ff 1f       	adc	r31, r31
 90c:	88 1f       	adc	r24, r24
 90e:	8b bf       	out	0x3b, r24	; 59
 910:	07 90       	elpm	r0, Z+
 912:	f6 91       	elpm	r31, Z
 914:	e0 2d       	mov	r30, r0
 916:	19 94       	eijmp

00000918 <calloc>:
 918:	0f 93       	push	r16
 91a:	1f 93       	push	r17
 91c:	cf 93       	push	r28
 91e:	df 93       	push	r29
 920:	86 9f       	mul	r24, r22
 922:	80 01       	movw	r16, r0
 924:	87 9f       	mul	r24, r23
 926:	10 0d       	add	r17, r0
 928:	96 9f       	mul	r25, r22
 92a:	10 0d       	add	r17, r0
 92c:	11 24       	eor	r1, r1
 92e:	c8 01       	movw	r24, r16
 930:	0d d0       	rcall	.+26     	; 0x94c <malloc>
 932:	ec 01       	movw	r28, r24
 934:	00 97       	sbiw	r24, 0x00	; 0
 936:	21 f0       	breq	.+8      	; 0x940 <calloc+0x28>
 938:	a8 01       	movw	r20, r16
 93a:	60 e0       	ldi	r22, 0x00	; 0
 93c:	70 e0       	ldi	r23, 0x00	; 0
 93e:	27 d1       	rcall	.+590    	; 0xb8e <memset>
 940:	ce 01       	movw	r24, r28
 942:	df 91       	pop	r29
 944:	cf 91       	pop	r28
 946:	1f 91       	pop	r17
 948:	0f 91       	pop	r16
 94a:	08 95       	ret

0000094c <malloc>:
 94c:	0f 93       	push	r16
 94e:	1f 93       	push	r17
 950:	cf 93       	push	r28
 952:	df 93       	push	r29
 954:	82 30       	cpi	r24, 0x02	; 2
 956:	91 05       	cpc	r25, r1
 958:	10 f4       	brcc	.+4      	; 0x95e <malloc+0x12>
 95a:	82 e0       	ldi	r24, 0x02	; 2
 95c:	90 e0       	ldi	r25, 0x00	; 0
 95e:	e0 91 25 02 	lds	r30, 0x0225	; 0x800225 <__flp>
 962:	f0 91 26 02 	lds	r31, 0x0226	; 0x800226 <__flp+0x1>
 966:	20 e0       	ldi	r18, 0x00	; 0
 968:	30 e0       	ldi	r19, 0x00	; 0
 96a:	a0 e0       	ldi	r26, 0x00	; 0
 96c:	b0 e0       	ldi	r27, 0x00	; 0
 96e:	30 97       	sbiw	r30, 0x00	; 0
 970:	19 f1       	breq	.+70     	; 0x9b8 <malloc+0x6c>
 972:	40 81       	ld	r20, Z
 974:	51 81       	ldd	r21, Z+1	; 0x01
 976:	02 81       	ldd	r16, Z+2	; 0x02
 978:	13 81       	ldd	r17, Z+3	; 0x03
 97a:	48 17       	cp	r20, r24
 97c:	59 07       	cpc	r21, r25
 97e:	c8 f0       	brcs	.+50     	; 0x9b2 <malloc+0x66>
 980:	84 17       	cp	r24, r20
 982:	95 07       	cpc	r25, r21
 984:	69 f4       	brne	.+26     	; 0x9a0 <malloc+0x54>
 986:	10 97       	sbiw	r26, 0x00	; 0
 988:	31 f0       	breq	.+12     	; 0x996 <malloc+0x4a>
 98a:	12 96       	adiw	r26, 0x02	; 2
 98c:	0c 93       	st	X, r16
 98e:	12 97       	sbiw	r26, 0x02	; 2
 990:	13 96       	adiw	r26, 0x03	; 3
 992:	1c 93       	st	X, r17
 994:	27 c0       	rjmp	.+78     	; 0x9e4 <malloc+0x98>
 996:	00 93 25 02 	sts	0x0225, r16	; 0x800225 <__flp>
 99a:	10 93 26 02 	sts	0x0226, r17	; 0x800226 <__flp+0x1>
 99e:	22 c0       	rjmp	.+68     	; 0x9e4 <malloc+0x98>
 9a0:	21 15       	cp	r18, r1
 9a2:	31 05       	cpc	r19, r1
 9a4:	19 f0       	breq	.+6      	; 0x9ac <malloc+0x60>
 9a6:	42 17       	cp	r20, r18
 9a8:	53 07       	cpc	r21, r19
 9aa:	18 f4       	brcc	.+6      	; 0x9b2 <malloc+0x66>
 9ac:	9a 01       	movw	r18, r20
 9ae:	bd 01       	movw	r22, r26
 9b0:	ef 01       	movw	r28, r30
 9b2:	df 01       	movw	r26, r30
 9b4:	f8 01       	movw	r30, r16
 9b6:	db cf       	rjmp	.-74     	; 0x96e <malloc+0x22>
 9b8:	21 15       	cp	r18, r1
 9ba:	31 05       	cpc	r19, r1
 9bc:	f9 f0       	breq	.+62     	; 0x9fc <malloc+0xb0>
 9be:	28 1b       	sub	r18, r24
 9c0:	39 0b       	sbc	r19, r25
 9c2:	24 30       	cpi	r18, 0x04	; 4
 9c4:	31 05       	cpc	r19, r1
 9c6:	80 f4       	brcc	.+32     	; 0x9e8 <malloc+0x9c>
 9c8:	8a 81       	ldd	r24, Y+2	; 0x02
 9ca:	9b 81       	ldd	r25, Y+3	; 0x03
 9cc:	61 15       	cp	r22, r1
 9ce:	71 05       	cpc	r23, r1
 9d0:	21 f0       	breq	.+8      	; 0x9da <malloc+0x8e>
 9d2:	fb 01       	movw	r30, r22
 9d4:	93 83       	std	Z+3, r25	; 0x03
 9d6:	82 83       	std	Z+2, r24	; 0x02
 9d8:	04 c0       	rjmp	.+8      	; 0x9e2 <malloc+0x96>
 9da:	90 93 26 02 	sts	0x0226, r25	; 0x800226 <__flp+0x1>
 9de:	80 93 25 02 	sts	0x0225, r24	; 0x800225 <__flp>
 9e2:	fe 01       	movw	r30, r28
 9e4:	32 96       	adiw	r30, 0x02	; 2
 9e6:	44 c0       	rjmp	.+136    	; 0xa70 <malloc+0x124>
 9e8:	fe 01       	movw	r30, r28
 9ea:	e2 0f       	add	r30, r18
 9ec:	f3 1f       	adc	r31, r19
 9ee:	81 93       	st	Z+, r24
 9f0:	91 93       	st	Z+, r25
 9f2:	22 50       	subi	r18, 0x02	; 2
 9f4:	31 09       	sbc	r19, r1
 9f6:	39 83       	std	Y+1, r19	; 0x01
 9f8:	28 83       	st	Y, r18
 9fa:	3a c0       	rjmp	.+116    	; 0xa70 <malloc+0x124>
 9fc:	20 91 23 02 	lds	r18, 0x0223	; 0x800223 <__brkval>
 a00:	30 91 24 02 	lds	r19, 0x0224	; 0x800224 <__brkval+0x1>
 a04:	23 2b       	or	r18, r19
 a06:	41 f4       	brne	.+16     	; 0xa18 <malloc+0xcc>
 a08:	20 91 02 02 	lds	r18, 0x0202	; 0x800202 <__malloc_heap_start>
 a0c:	30 91 03 02 	lds	r19, 0x0203	; 0x800203 <__malloc_heap_start+0x1>
 a10:	30 93 24 02 	sts	0x0224, r19	; 0x800224 <__brkval+0x1>
 a14:	20 93 23 02 	sts	0x0223, r18	; 0x800223 <__brkval>
 a18:	20 91 00 02 	lds	r18, 0x0200	; 0x800200 <__data_start>
 a1c:	30 91 01 02 	lds	r19, 0x0201	; 0x800201 <__data_start+0x1>
 a20:	21 15       	cp	r18, r1
 a22:	31 05       	cpc	r19, r1
 a24:	41 f4       	brne	.+16     	; 0xa36 <malloc+0xea>
 a26:	2d b7       	in	r18, 0x3d	; 61
 a28:	3e b7       	in	r19, 0x3e	; 62
 a2a:	40 91 04 02 	lds	r20, 0x0204	; 0x800204 <__malloc_margin>
 a2e:	50 91 05 02 	lds	r21, 0x0205	; 0x800205 <__malloc_margin+0x1>
 a32:	24 1b       	sub	r18, r20
 a34:	35 0b       	sbc	r19, r21
 a36:	e0 91 23 02 	lds	r30, 0x0223	; 0x800223 <__brkval>
 a3a:	f0 91 24 02 	lds	r31, 0x0224	; 0x800224 <__brkval+0x1>
 a3e:	e2 17       	cp	r30, r18
 a40:	f3 07       	cpc	r31, r19
 a42:	a0 f4       	brcc	.+40     	; 0xa6c <malloc+0x120>
 a44:	2e 1b       	sub	r18, r30
 a46:	3f 0b       	sbc	r19, r31
 a48:	28 17       	cp	r18, r24
 a4a:	39 07       	cpc	r19, r25
 a4c:	78 f0       	brcs	.+30     	; 0xa6c <malloc+0x120>
 a4e:	ac 01       	movw	r20, r24
 a50:	4e 5f       	subi	r20, 0xFE	; 254
 a52:	5f 4f       	sbci	r21, 0xFF	; 255
 a54:	24 17       	cp	r18, r20
 a56:	35 07       	cpc	r19, r21
 a58:	48 f0       	brcs	.+18     	; 0xa6c <malloc+0x120>
 a5a:	4e 0f       	add	r20, r30
 a5c:	5f 1f       	adc	r21, r31
 a5e:	50 93 24 02 	sts	0x0224, r21	; 0x800224 <__brkval+0x1>
 a62:	40 93 23 02 	sts	0x0223, r20	; 0x800223 <__brkval>
 a66:	81 93       	st	Z+, r24
 a68:	91 93       	st	Z+, r25
 a6a:	02 c0       	rjmp	.+4      	; 0xa70 <malloc+0x124>
 a6c:	e0 e0       	ldi	r30, 0x00	; 0
 a6e:	f0 e0       	ldi	r31, 0x00	; 0
 a70:	cf 01       	movw	r24, r30
 a72:	df 91       	pop	r29
 a74:	cf 91       	pop	r28
 a76:	1f 91       	pop	r17
 a78:	0f 91       	pop	r16
 a7a:	08 95       	ret

00000a7c <free>:
 a7c:	cf 93       	push	r28
 a7e:	df 93       	push	r29
 a80:	00 97       	sbiw	r24, 0x00	; 0
 a82:	09 f4       	brne	.+2      	; 0xa86 <free+0xa>
 a84:	81 c0       	rjmp	.+258    	; 0xb88 <free+0x10c>
 a86:	fc 01       	movw	r30, r24
 a88:	32 97       	sbiw	r30, 0x02	; 2
 a8a:	13 82       	std	Z+3, r1	; 0x03
 a8c:	12 82       	std	Z+2, r1	; 0x02
 a8e:	a0 91 25 02 	lds	r26, 0x0225	; 0x800225 <__flp>
 a92:	b0 91 26 02 	lds	r27, 0x0226	; 0x800226 <__flp+0x1>
 a96:	10 97       	sbiw	r26, 0x00	; 0
 a98:	81 f4       	brne	.+32     	; 0xaba <free+0x3e>
 a9a:	20 81       	ld	r18, Z
 a9c:	31 81       	ldd	r19, Z+1	; 0x01
 a9e:	82 0f       	add	r24, r18
 aa0:	93 1f       	adc	r25, r19
 aa2:	20 91 23 02 	lds	r18, 0x0223	; 0x800223 <__brkval>
 aa6:	30 91 24 02 	lds	r19, 0x0224	; 0x800224 <__brkval+0x1>
 aaa:	28 17       	cp	r18, r24
 aac:	39 07       	cpc	r19, r25
 aae:	51 f5       	brne	.+84     	; 0xb04 <free+0x88>
 ab0:	f0 93 24 02 	sts	0x0224, r31	; 0x800224 <__brkval+0x1>
 ab4:	e0 93 23 02 	sts	0x0223, r30	; 0x800223 <__brkval>
 ab8:	67 c0       	rjmp	.+206    	; 0xb88 <free+0x10c>
 aba:	ed 01       	movw	r28, r26
 abc:	20 e0       	ldi	r18, 0x00	; 0
 abe:	30 e0       	ldi	r19, 0x00	; 0
 ac0:	ce 17       	cp	r28, r30
 ac2:	df 07       	cpc	r29, r31
 ac4:	40 f4       	brcc	.+16     	; 0xad6 <free+0x5a>
 ac6:	4a 81       	ldd	r20, Y+2	; 0x02
 ac8:	5b 81       	ldd	r21, Y+3	; 0x03
 aca:	9e 01       	movw	r18, r28
 acc:	41 15       	cp	r20, r1
 ace:	51 05       	cpc	r21, r1
 ad0:	f1 f0       	breq	.+60     	; 0xb0e <free+0x92>
 ad2:	ea 01       	movw	r28, r20
 ad4:	f5 cf       	rjmp	.-22     	; 0xac0 <free+0x44>
 ad6:	d3 83       	std	Z+3, r29	; 0x03
 ad8:	c2 83       	std	Z+2, r28	; 0x02
 ada:	40 81       	ld	r20, Z
 adc:	51 81       	ldd	r21, Z+1	; 0x01
 ade:	84 0f       	add	r24, r20
 ae0:	95 1f       	adc	r25, r21
 ae2:	c8 17       	cp	r28, r24
 ae4:	d9 07       	cpc	r29, r25
 ae6:	59 f4       	brne	.+22     	; 0xafe <free+0x82>
 ae8:	88 81       	ld	r24, Y
 aea:	99 81       	ldd	r25, Y+1	; 0x01
 aec:	84 0f       	add	r24, r20
 aee:	95 1f       	adc	r25, r21
 af0:	02 96       	adiw	r24, 0x02	; 2
 af2:	91 83       	std	Z+1, r25	; 0x01
 af4:	80 83       	st	Z, r24
 af6:	8a 81       	ldd	r24, Y+2	; 0x02
 af8:	9b 81       	ldd	r25, Y+3	; 0x03
 afa:	93 83       	std	Z+3, r25	; 0x03
 afc:	82 83       	std	Z+2, r24	; 0x02
 afe:	21 15       	cp	r18, r1
 b00:	31 05       	cpc	r19, r1
 b02:	29 f4       	brne	.+10     	; 0xb0e <free+0x92>
 b04:	f0 93 26 02 	sts	0x0226, r31	; 0x800226 <__flp+0x1>
 b08:	e0 93 25 02 	sts	0x0225, r30	; 0x800225 <__flp>
 b0c:	3d c0       	rjmp	.+122    	; 0xb88 <free+0x10c>
 b0e:	e9 01       	movw	r28, r18
 b10:	fb 83       	std	Y+3, r31	; 0x03
 b12:	ea 83       	std	Y+2, r30	; 0x02
 b14:	49 91       	ld	r20, Y+
 b16:	59 91       	ld	r21, Y+
 b18:	c4 0f       	add	r28, r20
 b1a:	d5 1f       	adc	r29, r21
 b1c:	ec 17       	cp	r30, r28
 b1e:	fd 07       	cpc	r31, r29
 b20:	61 f4       	brne	.+24     	; 0xb3a <free+0xbe>
 b22:	80 81       	ld	r24, Z
 b24:	91 81       	ldd	r25, Z+1	; 0x01
 b26:	84 0f       	add	r24, r20
 b28:	95 1f       	adc	r25, r21
 b2a:	02 96       	adiw	r24, 0x02	; 2
 b2c:	e9 01       	movw	r28, r18
 b2e:	99 83       	std	Y+1, r25	; 0x01
 b30:	88 83       	st	Y, r24
 b32:	82 81       	ldd	r24, Z+2	; 0x02
 b34:	93 81       	ldd	r25, Z+3	; 0x03
 b36:	9b 83       	std	Y+3, r25	; 0x03
 b38:	8a 83       	std	Y+2, r24	; 0x02
 b3a:	e0 e0       	ldi	r30, 0x00	; 0
 b3c:	f0 e0       	ldi	r31, 0x00	; 0
 b3e:	12 96       	adiw	r26, 0x02	; 2
 b40:	8d 91       	ld	r24, X+
 b42:	9c 91       	ld	r25, X
 b44:	13 97       	sbiw	r26, 0x03	; 3
 b46:	00 97       	sbiw	r24, 0x00	; 0
 b48:	19 f0       	breq	.+6      	; 0xb50 <free+0xd4>
 b4a:	fd 01       	movw	r30, r26
 b4c:	dc 01       	movw	r26, r24
 b4e:	f7 cf       	rjmp	.-18     	; 0xb3e <free+0xc2>
 b50:	8d 91       	ld	r24, X+
 b52:	9c 91       	ld	r25, X
 b54:	11 97       	sbiw	r26, 0x01	; 1
 b56:	9d 01       	movw	r18, r26
 b58:	2e 5f       	subi	r18, 0xFE	; 254
 b5a:	3f 4f       	sbci	r19, 0xFF	; 255
 b5c:	82 0f       	add	r24, r18
 b5e:	93 1f       	adc	r25, r19
 b60:	20 91 23 02 	lds	r18, 0x0223	; 0x800223 <__brkval>
 b64:	30 91 24 02 	lds	r19, 0x0224	; 0x800224 <__brkval+0x1>
 b68:	28 17       	cp	r18, r24
 b6a:	39 07       	cpc	r19, r25
 b6c:	69 f4       	brne	.+26     	; 0xb88 <free+0x10c>
 b6e:	30 97       	sbiw	r30, 0x00	; 0
 b70:	29 f4       	brne	.+10     	; 0xb7c <free+0x100>
 b72:	10 92 26 02 	sts	0x0226, r1	; 0x800226 <__flp+0x1>
 b76:	10 92 25 02 	sts	0x0225, r1	; 0x800225 <__flp>
 b7a:	02 c0       	rjmp	.+4      	; 0xb80 <free+0x104>
 b7c:	13 82       	std	Z+3, r1	; 0x03
 b7e:	12 82       	std	Z+2, r1	; 0x02
 b80:	b0 93 24 02 	sts	0x0224, r27	; 0x800224 <__brkval+0x1>
 b84:	a0 93 23 02 	sts	0x0223, r26	; 0x800223 <__brkval>
 b88:	df 91       	pop	r29
 b8a:	cf 91       	pop	r28
 b8c:	08 95       	ret

00000b8e <memset>:
 b8e:	dc 01       	movw	r26, r24
 b90:	01 c0       	rjmp	.+2      	; 0xb94 <memset+0x6>
 b92:	6d 93       	st	X+, r22
 b94:	41 50       	subi	r20, 0x01	; 1
 b96:	50 40       	sbci	r21, 0x00	; 0
 b98:	e0 f7       	brcc	.-8      	; 0xb92 <memset+0x4>
 b9a:	08 95       	ret

00000b9c <_exit>:
 b9c:	f8 94       	cli

00000b9e <__stop_program>:
 b9e:	ff cf       	rjmp	.-2      	; 0xb9e <__stop_program>
